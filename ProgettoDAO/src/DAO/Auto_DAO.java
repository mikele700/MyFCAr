package DAO;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class Auto_DAO {

	protected static java.util.Map<Integer, Auto> restoredObjects = new java.util.HashMap<Integer, Auto>();
	
	/*
	 * Crea una nuova oggetto persistente della classe Auto con chiave ID. 
	 */
	static public Auto create(int ID) throws SQLException  {
		Connection c = DBManager.getConnection();
		PreparedStatement pstat = c.prepareStatement("INSERT INTO Aziende (ID) VALUES (?)");
		pstat.setInt(1, ID);
		pstat.executeUpdate();		
		pstat.close();
		
		Auto a = new Auto(ID); 
		restoredObjects.put(ID, a);
		return a;
	}
	
	/*
	 * Crea una nuova oggetto persistente della classe Auto con chiave autogenerata. 
	 */
	static public Auto create() throws SQLException  {
		Connection c = DBManager.getConnection();
		Statement stat = c.createStatement();
		int id;
		try {
			stat.executeUpdate("INSERT INTO Aziende (Nome) VALUES ('')");
			ResultSet rs = stat.getGeneratedKeys();
			if (rs.next() == false) {
				throw new SQLException("ID value was not autogenerated!");
			}
			id = rs.getInt(1);
		} finally {
			stat.close();
		}
		Auto a = new Auto(ID); 
		restoredObjects.put(id, a);
		return a;
	}
	
	/*
	 * Restituisce l'oggetto persistente Auto che è identificato dalla chiave ID.
	 * 
	 * Nelle basi di dati relazionali le entità sono individuate univocamente in base alla chiave primaria (ID).
	 * Le associazioni sono realizzate grazie ai vincoli inter-relazionali, imponendo vincoli di foreign key e 
	 * referenziando le chiavi primarie delle entità coinvolte nell'associazione.
	 * 
	 * Nel mondo ad oggetti le istanze sono esse stesse le entità, e le associazioni si realizzano in base 
	 * ai riferimenti alle istanze e non in base ad un sottoinsieme di attributi. Pertanto, uno dei problemi
	 * dell'impedance mismatching è quello di trasformare le associazioni delle basi di dati relazionali
	 * in associazioni nel mondo degli oggetti.
	 * 
	 * In questa soluzione di persistenza, ci serviamo di una struttura dati map per avere memoria
	 * della traduzione <primary_key, instance>. In questo modo possiamo convertire agevolmente le associazioni
	 * del mondo relazionale in associazioni del mondo degli oggetti, evitando di creare duplicati di una entità
	 * persistente durante l'esecuzione dell'applicazione.
	 * 
	 * Se si invoca il metodo read(ID) e l'entità del dominio degli oggetti che risponde all'identificativo "ID" 
	 * è già presente nell'ambiente di esecuzione, grazie alla map si ottiene il riferimento all'oggetto; altrimenti 
	 * il sottoprogramma ripristina l'entità dal mondo relazionale, in base alle regole di mapping. 
	 * 
	 */
	static public Auto read(int ID) throws SQLException {
		if (restoredObjects.containsKey(ID)) 
			return restoredObjects.get(ID);
		
		Auto a = null;
		Connection c = DBManager.getConnection();
		
		PreparedStatement pstat = c.prepareStatement("SELECT * FROM Aziende WHERE ID=?");
		pstat.setInt(1, ID);
		ResultSet rs = pstat.executeQuery();
		if (rs.next() == true) {
			a = new Auto(ID);
			restoredObjects.put(ID, a);
			
			try {
				a.setNome(rs.getString("Nome"));
				Statement stmt = c.createStatement();
				rs = stmt.executeQuery("SELECT ID FROM Impiegati where Auto=" + String.valueOf(ID));
		//		while (rs.next()) {
		//			int impiegatoID = rs.getInt(1);
		//			a.addImpiegato(Impiegato_DAO.read(impiegatoID));
		//		}
				stmt.close();
				
			} catch (SQLException e) {
				restoredObjects.remove(ID);
				throw e;
			}
		}
		pstat.close();
		
		return a;
	}
	
	/*
	 * Rende persistente il nuovo stato assunto dall'oggetto a.
	 */
	public static void update(Auto a) throws SQLException {
		if (a.getId() == null) {
			/* 
			 * Se aziendaID == NULL, allora l'oggetto "Auto a" non era persistente.
			 * Si e' scelto di rendere l'oggetto persistente facendo prima una operazione
			 * di create() per ottenere un nuovo ID, e quindi effettua una operazione
			 * di update per far coincidere la nuova istanza con l'oggetto "Auto a".
			 * 
			 * Un'altra implementazione poteva direttamente scegliere di fare una sola 
			 * operazione di INSERT sui dati di "Auto a".
			 */
			Auto newAuto = Auto_DAO.create(); // Ottengo un nuovo ID
			a.setId(newAuto.getId());
			/* 
			 * Modifico riferimento nella map all'oggetto, ormai reso persistente, "Auto a" 
			 * e scarto l'instanza newAuto (che coincide di attributo ID).
			 */
			restoredObjects.put(a.getId(), a); 
		}
		Connection conn = DBManager.getConnection();
		PreparedStatement stmt = conn.prepareStatement("UPDATE Aziende SET Nome=? WHERE ID=?");
		stmt.setString(1, a.getNome());
		stmt.setInt(2, a.getId());
		stmt.executeUpdate();
		
		/*
		 * Un oggetto DAO ha cura di aggiornare anche le associazioni.
		 * Questa implementazione adotta il seguente algoritmo per aggiornare l'associazione tra azienda e 
		 * impiegato:
		 * - prima inizializza a NULL l'azienda per tutti gli impiegati precedentemente associati ad "Auto a"
		 * - quindi rende persistente lo stato di tutti gli impiegati ora collegati ad "Auto a" 
		 */
		Statement clStmt = conn.createStatement();
		clStmt.executeUpdate("UPDATE Impiegati SET Auto=NULL WHERE Auto=" + a.getId().toString());
		
		for (int i = 0; i < a.getNumImpiegati(); i++) {
			Impiegato_DAO.update(a.getImpiegato(i));
		}
	}
	
	/*
	 * Elimina l'oggetto persistente a.
	 */
	static public void delete(Auto a) throws SQLException {
		Integer aziendaID = a.getId();
		if (aziendaID != null) {
			// Oggetto persistente
			Connection c = DBManager.getConnection();
			Statement stmt = c.createStatement();
			stmt.executeUpdate("UPDATE Impiegati SET Auto=NULL WHERE Auto=" + aziendaID.toString());
			stmt.executeUpdate("DELETE FROM Aziende WHERE ID=" + aziendaID.toString());
			stmt.close();
			
			restoredObjects.remove(a);
			// Si rende l'oggetto transiente (non persistente -- non presente nel mondo relazionale)
			a.setId(null);
		}
	}
	
	
}
